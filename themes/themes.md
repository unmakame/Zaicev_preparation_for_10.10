Структуры данных
1) Уровни описания структур данных
- Логический уровень: На этом уровне описывается логическая структура объектов и их
функциональное поведение. Он определяет, какие операции могут быть выполнены над объектами и как
они взаимодействуют друг с другом. Примером является сплошное представление объектов, где объекты
рассматриваются как непрерывные сущности, доступ к которым осуществляется через индексное
вычисление.
- Физический уровень: На этом уровне рассматривается физическое представление объектов и способы
их хранения и доступа к ним. В приведенном тексте упоминаются два физических представления -
сплошное и цепное. Сплошное представление подразумевает хранение объектов в памяти компьютера
последовательно, а доступ к элементам осуществляется через вычисление индексов. Цепное
представление предполагает разделение объекта на части, которые хранятся в разных участках памяти и
связаны указателями.
- Аппаратный уровень: На этом уровне рассматривается аппаратная поддержка структур данных.
Упоминается, что для внешних электромеханических устройств, основанных на последовательном
движении носителя, сплошное представление является единственно возможным.
Каждый из этих уровней предоставляет различную абстракцию и детализацию описания структур
данных, начиная от логического определения их функциональности до физического и аппаратного
представления в конкретной системе

2) Файл
Файл - динамический объект, расположенный во внешней памяти ЭВМ. Может быть пустым. Однако каждый файл должен иметь свое имя, чтобы его можно было отыскать в определенном участке внешней памяти в ЭВМ.

Операции над файлами: чтение, запись, стирание. 
В зависимости от типа устройств, на котором хранятся файлы, набор операций может ограничиваться. 

Общее определение файла - это последовательность элементов одного типа в любой момент времени доступна только текущая компонента. 

Файлы бывают: 
внутренние (временные) - описаны в разделе программы и их время жизни совпадает с временем жизни программы или даже меньше. 
внешние - существуют до выполнения программы и после. описаны в разделе программы и в заголовке. 

- 2.1) Функциональная спецификация
    Обозначим за F(t) файловый тип данных c компонентами типа t. Значениями файлового типа F(t) являются сколь угодно длинные, но конечные последовательности компонент типа t. Такое множество значений можно формально определить с помощью операции конкатенации нескольких файлов.

    Правила: 
    1) {} - пустой файл F(t)
    2)если f - файл F(t). то f || t - F(t) (тоже файл) /|| - конкатенация
    3)никакие другие значения не являются файлом типа F(t)

    Базовое множество атрибутов файлового типа:
    1 Отношение эквивалентности (если равны длины файлов и все элементы соответственно)
    2 Операция присваивания( копирование поэлементное  копирование одного файла в другой)
    3 Операция конкатенации
    4 Базовые функции (создание, доступ, модифицирование, уничтожение)
           
- 2.2) Логическое описание и физическое представление
Файлы в программировании – это динамические объекты, представляющие последовательность компонентов одного типа. Они могут храниться как в основной, так и во внешней памяти и иметь собственное имя для идентификации. Файл может быть пустым или содержать элементы, которые можно добавлять или удалять. В Паскале файлы реализованы как именованный тип с буферной переменной для работы с компонентами, основные операции: reset для чтения, rewrite для записи, get для получения компоненты и put для добавления. В Си файлы представлены типом FILE* как дескриптор, работа осуществляется через стандартную библиотеку <stdio.h>, можно работать с текстовыми и двоичными файлами. Физически компоненты файла могут храниться в памяти или на внешних устройствах, доступ к текущей компоненте обеспечивается буфером или дескриптором. Файлы ассоциированы с внешними устройствами, такими как диски, терминалы и принтеры. Суть файлов заключается в возможности хранить, читать, записывать и модифицировать данные последовательно, как в памяти, так и на внешних устройствах.

3) Вектор (уметь написать на си)
Векторы, или динамические массивы, представляют собой удобную альтернативу статическим массивам
с фиксированной длиной. Они позволяют задавать размер массива произвольно, избегая ограничений и
непроизводительных затрат. Динамические массивы размещаются в куче и могут быть изменены в
размере в соответствии с требованиями программы. Однако, возможны более длительные времена
доступа к элементам из-за иерархической структуры памяти в современных компьютерах.
Критика векторов, основанная на необходимости ручного распределения памяти, устарела.
Современные языки программирования, такие как Java и C++, обеспечивают механизмы автоматической
проверки границ массивов и обращений к памяти. Например, класс std::vector в C++ предоставляет два
способа доступа к элементам: непосредственный через оператор [] и проверяемый через функцию-член
at. Это позволяет программисту выбрать наиболее подходящий способ с учетом требований
производительности.
    - 3.1) Функциональная спецификация
    Функциональная спецификация для вектора представляет собой последовательность переменной
    длины, где доступ к элементам осуществляется за постоянное время, независимо от длины вектора.
    Вектор может быть пустым, то есть не содержать компонентов. Операции, такие как сложение и
    скалярное произведение, могут выполняться только между векторами одинаковой размерности. Длина
    вектора определяет его размерность и может быть изменена путем увеличения или уменьшения
    количества компонентов. При изменении размера вектора происходит копирование элементов, что
    может быть неэффективно. Цель функциональной спецификации состоит в обеспечении постоянного
    времени доступа к данным вектора

    - 3.2) Логическое описание и физическое представление
    Логическое описание вектора представляет собой описание хранимой последовательности элементов и её длины. Проверка на пустоту осуществляется сравнением длины с нулём, а два вектора считаются равными, если их длины совпадают и соответствующие элементы равны. В языке C операции чтения и записи элементов по индексу не проверяют границы массива, поэтому выход за пределы массива может привести к ошибке. Для изменения размера вектора используется функция realloc, которая позволяет динамически увеличивать или уменьшать ёмкость вектора. После завершения работы с вектором память освобождается вызовом функции free. Реализация вектора может быть усложнена с учётом оптимизации использования памяти и повышения производительности, включая предвыделение памяти, управление ёмкостью и эффективный доступ к элементам. В целом, логическое описание вектора задаёт его функциональные свойства, включая хранение, доступ, сравнение и изменение размера последовательности элементов, независимо от конкретной физической реализации.

АТД вектор на си
```
#include <stdio.h>
#include <stdlib.h>


typedef struct{
    int *data;
    int size;
    int capacity;
} Vector;

void init(Vector *v, int capacity){
    v->data = (int*)malloc(capacity * sizeof(int));
    v->size = 0;
    v->capacity = capacity;
}

void resize(Vector *v){
    if (v->size == v->capacity){
        v->capacity *= 2;
        v->data = (int*)realloc(v->data,v->capacity * sizeof(int));
    }
}

void push_back(Vector *v,int value){
    if (v->size == v->capacity){
        resize(v);
    }
    v->data[v->size++] = value;
}


void pop_back(Vector *v){
    if(v->size > 0){
        v->size--;
    }
}

int get(Vector *v,int index){
    if (index >= 0 && index <= v-> size){
        return v->data[index];
    }
    return -1;
}

void free_vector(Vector *v){
    free(v->data);
    v->data = NULL;
    v->size = 0;
    v->capacity = 1;
}


```
    
4) Очередь (уметь написать на си)
    - 4.1) Функциональная спецификаци
    - 4.2) Логическое описание и физическое представление
5) Стек (уметь написать на си)
    - 5.1) Функциональная спецификация
    - 5.2) Логическое описание
6) Линейный список (уметь написать на си)
    - 6.1) Функциональная спецификация
    - 6.2) Логическое описание
    - 6.3) Физическое представление
7) Дек (уметь написать на си)
8) Списки общего вида
9) Понятие о рекурсии - (до 4.10 включительно)
10) Деревья (уметь написать на си)
    - 10.1) Двоичные деревья
    - 10.2) Двоичная интерпретация дерева общего вида
    - 10.3) Функциональная спецификация
    - 10.4) Логическое описание
11) Алгоритмы обработки деревьев (уметь написать на си)
    - 11.1) Понятие обхода дерева
    - 11.2) Алгоритмы обхода двоичных деревьев
    - 11.3) Построение и визуализация дерева
    - 11.4) Деревья выражений. Разнофиксные формы записи выражений
    - 11.5) Обход дерева общего вида
    - 11.6) Физическое представление. Отображение на массив
12) Деревья поиска (уметь написать на си)
    - 12.1) Поиск по дереву с включениями
    - 12.2) Исключение из деревьев
    - 12.3) Сбалансированные деревья поиска
13) Графы (уметь написать на си)
    - 13.1) Алгоритмы на графах

Сортировка и поиск**
1) Алгоритмы поиска (уметь написать на си)
    - 1.1) Линейный поиск
    - 1.2) Двоичный поиск
    - 1.3) Поиск в таблице
    - 1.4) Поиск по образцу
    - 1.5) Алгоритм Кнута-Мориса-Пратта
    - 1.6) Алгоритм Бойера-Мура
    - 1.7) Алгоритм Рабина-Карпа
2) Алгоритмы сортировки (уметь написать на си)
    - 2.1) Сортировка массивов
    - 2.2) Сравнительный анализ методов внутренней сортировки
    - 2.3) Другие идеи сортировки
    - 2.4) Сортировки за линейное время
    - 2.5) Внешние сортировки
3) Таблицы с прямым доступом
    - 3.1) Выбор хеш-функции
    - 3.2) Рехеширование
    - 3.3) Совершенная хеш-функция

Методы программирования
1) Модульное программирование
    - 1.1) Разреженные матрицы
    - 1.2) Экспорт и импорт объектов
2) Программирование в абстрактных типах данных
    - 2.1) Методы абстракции в языках программирования
    - 2.2) Виды абстракции в языках программирования
3) Типовые абстракции
    - 3.1) Типизация языка
    - 3.2) Контроль типов
    - 3.3) Преобразование и передача типов
    - 3.4) Адресный тип
    - 3.5) Родовые модули
    - 3.6) Полиморфизм
    - 3.7) Процедурный тип

*
**
- умение реализовать на языке С
- Знание основных характеристик, О-нотациютруктуры данных
