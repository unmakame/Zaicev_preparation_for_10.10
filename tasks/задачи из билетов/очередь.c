#include <stdio.h>   // Подключаем стандартную библиотеку ввода-вывода (printf и т.д.)
#include <stdlib.h>  // Подключаем стандартную библиотеку для работы с памятью (malloc, free)

// Определяем структуру узла очереди
typedef struct Node {
    int data;            // Поле данных (будем хранить целое число)
    struct Node* next;   // Указатель на следующий элемент (узел) очереди
} Node;

// Определяем структуру очереди
typedef struct {
    Node *f, *r;   // f (front) — голова очереди, r (rear) — хвост очереди
} Queue;

// Функция создания новой очереди
Queue* create() {
    Queue* q = malloc(sizeof(Queue)); // Выделяем память под структуру Queue
    q->f = q->r = NULL;               // Изначально очередь пустая (оба указателя NULL)
    return q;                         // Возвращаем указатель на созданную очередь
}

// Проверка на пустоту
int empty(Queue* q) {
    return !q->f;   // Если указатель на голову равен NULL, возвращаем 1 (пусто), иначе 0
}

// Добавление элемента в очередь (enqueue)
void enqueue(Queue* q, int x) {
    Node* n = malloc(sizeof(Node)); // Выделяем память для нового узла
    n->data = x;                    // Записываем в поле data переданное значение
    n->next = NULL;                 // Новый элемент всегда вставляется в конец, поэтому next = NULL

    if (q->r)                       // Если очередь НЕ пуста (есть хвост)
        q->r->next = n;             // Старый хвост теперь должен ссылаться на новый узел
    else
        q->f = n;                   // Если очередь была пуста, новый элемент становится и головой

    q->r = n;                       // В любом случае, новый элемент становится хвостом
}

// Удаление элемента из очереди (dequeue)
int dequeue(Queue* q) {
    if (empty(q))                   // Если очередь пуста
        return -1;                  // Возвращаем -1 (признак ошибки/пустой очереди)

    Node* t = q->f;                 // Временный указатель на голову (узел для удаления)
    int x = t->data;                // Сохраняем значение, которое нужно вернуть
    q->f = t->next;                 // Перемещаем голову на следующий элемент

    if (!q->f)                      // Если очередь стала пустой (нет головы)
        q->r = NULL;                // То и хвост тоже обнуляем

    free(t);                        // Освобождаем память удалённого узла
    return x;                       // Возвращаем извлечённое значение
}

// Главная функция (тест)
int main() {
    Queue* q = create();            // Создаём новую очередь

    enqueue(q, 10);                 // Добавляем число 10 в очередь
    enqueue(q, 20);                 // Добавляем число 20
    enqueue(q, 30);                 // Добавляем число 30

    printf("%d\n", dequeue(q));     // Извлекаем и печатаем первый элемент (10)
    printf("%d\n", dequeue(q));     // Извлекаем и печатаем следующий элемент (20)

    enqueue(q, 40);                 // Добавляем число 40 (теперь очередь содержит 30 и 40)

    while (!empty(q))               // Пока очередь не пуста
        printf("%d\n", dequeue(q)); // Извлекаем и печатаем элементы (сначала 30, потом 40)

    return 0;                       // Успешное завершение программы
}
