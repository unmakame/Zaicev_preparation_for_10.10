
# Билет 1
## Алгоритм Кнутта-Морриса-Партта(поиск подстроки в строке с помощью таблицы индексов)
Лирическое отступление
```
Алгоритм Кнута-Морриса-Парта - алгоритм поиска подстроки в строке, придуман в 1977 году, 
основная идея алгоритма 
сдвигать слово не полностью(как в прямом поиске где при несовпадении символа слово сдвигается на 1), 
а по максимальному префиксу 
```
Алгоритм КМП - предназначен для поиска подстроки в строке, позволяет выпонлять поиск с линейной сложность O(n), где n - длина строки в которой производится поиск. Алгоритм использует таблицу Префиксов и Суффиксов которая позволяет понять с какой пощиции начать если сравнение неудачное( не равны символы).

Сам алгоритм выглядит так 

1. Создается таблица префиксов и суффиксов подстроки  
2. Инициализируются переменные для сравнения: `i` - индекс строки, `j` - индекс символа  
3. Начинается сравнение подстроки с строкой с текущих индексов `i` и `j`  
    - Если символы совпали, то увеличиваем `i` и `j` на 1  
    - Если символы не совпали:  
        - Пока `j > 0`:  
            - `i` оставляем неизменным, а вместо `j` ставим элемент из таблицы с индексом `[j - 1]`  
        - Если `j == 0`:  
            - Прибавляем 1 к `i`  
4. Повторяем шаг 3, пока не достигнут конец строки или образца  
5. Если достигнут конец подстроки, то найдено полное совпадение. Возвращаем позицию в строке, где начинается совпадение  
6. Если кончилась строка, то совпадение не найдено  


Благодаря таблице префиксов и суффиксов алгоритм позволяет избежать многократный сравнений уже проверенных символов. Это похволяет достичь более быстрого и эффективного поиска подстроки в строке.ъ

## быстрая сортировка хоара рекурсивно
[полезное видео](https://youtu.be/HjVE1ei28_I?si=Y4qOvQkKbFxk9lYZ)
50. Сортировка Хоара.
Сортировка Хоара, также известная как быстрая сортировка, является одним из самых популярных
алгоритмов сортировки. Он был разработан сэром Чарльзом Хоаром в 1959 году и изначально
представлялся в виде разделения массива на подмассивы, сортировки каждого из них отдельно и
объединения полученных результатов.
Алгоритм работает следующим образом:
1. Выбирается элемент массива, называемый опорным (pivot). Обычно в качестве опорного выбирается
средний элемент или случайный элемент.
2. Все элементы, меньшие опорного, перемещаются влево от него, а все элементы, большие опорного,
перемещаются вправо от него. После этого опорный элемент оказывается на своем окончательном
месте.
3. Процедура рекурсивно применяется к подмассивам слева и справа от опорного элемента.
Плюсы сортировки Хоара:
1. Быстрая: В большинстве случаев демонстрирует хорошую производительность. В среднем его
сложность O(n log n).
2. Использует простые операции: применяет только простые операции сравнения и обмена элементов
массива.
3. Использует пространство памяти в малых количествах: выполняет сортировку на месте, то есть не
требует дополнительной памяти для хранения отсортированного массива.
Минусы сортировки Хоара:
1. Неустойчивость: не гарантирует сохранение порядка равных элементов. Это может быть проблемой,
если необходимо сортировать объекты с несколькими ключами.
2. Худший случай: В худшем случае, когда выбирается неподходящий опорный элемент или массив уже
отсортирован в обратном порядке, время выполнения QuickSort может быть O(n^2), что делает его менее
эффективным по сравнению с другими алгоритмами, такими как сортировка слиянием.
3. Рекурсивные вызовы: QuickSort использует рекурсию для сортировки подмассивов, что может
вызывать проблемы с памятью при обработке очень больших массивов.
Сложностная оценка сортировки Хоара: O(n log n), в худшем случае: O(n^2)

```
#include <stdio.h>   // Подключаем стандартную библиотеку для printf (для вывода)

// Функция для обмена двух элементов массива
void swap(int *a, int *b) {
    int temp = *a;   // Сохраняем значение *a во временную переменную
    *a = *b;         // Записываем в *a значение *b
    *b = temp;       // В *b помещаем старое значение *a
}

// Функция разбиения массива (partition) по схеме Хоара
int partition(int arr[], int low, int high) {
    int pivot = arr[(low + high) / 2]; // Опорный элемент: берём середину массива
    int i = low - 1;   // Индекс слева (будет двигаться вправо)
    int j = high + 1;  // Индекс справа (будет двигаться влево)

    while (1) {        // Бесконечный цикл — выйдем через return
        do { i++; } while (arr[i] < pivot);  // Сдвигаем i вправо, пока элементы меньше опорного
        do { j--; } while (arr[j] > pivot);  // Сдвигаем j влево, пока элементы больше опорного

        if (i >= j)    // Если индексы пересеклись или встретились — возвращаем j
            return j;

        swap(&arr[i], &arr[j]); // Иначе меняем arr[i] и arr[j] местами
    }
}

// Рекурсивная реализация быстрой сортировки
void quicksort(int arr[], int low, int high) {
    if (low < high) {                  // Базовое условие рекурсии: пока подмассив не пустой
        int p = partition(arr, low, high); // Разбиваем массив, получаем индекс разделения
        quicksort(arr, low, p);            // Рекурсивно сортируем левую часть (от low до p)
        quicksort(arr, p + 1, high);       // Рекурсивно сортируем правую часть (от p+1 до high)
    }
}

// Тест программы
int main() {
    int arr[] = {34, 7, 23, 32, 5, 62};   // Исходный массив
    int n = sizeof(arr) / sizeof(arr[0]); // Размер массива

    quicksort(arr, 0, n - 1); // Сортируем массив целиком

    printf("Отсортированный массив:\n");
    for (int i = 0; i < n; i++)           // Выводим результат
        printf("%d ", arr[i]);
    printf("\n");

    return 0; // Успешное завершение программы
}
```
# Билет 2
## алгоритм Бойера Мура	

## решение выражения ПОЛИЗ(Обратная польская) на С блять


# Билет 3
## Алгоритм Рабина карпа	

## Сортировка Шелла на Си реализация


# Билет 4
## атд двунаправленный кольцевой список 	

## быстрая сортировка Хоара (не рекурсия)


# Билет 5
## сбалансированные деревья	

## реализация атд очереди на массиве


# Билет 6
## атд двоичное дерево	реализация 

## атд очередь динамических структур данных


# Билет 7
## Сбалансированные деревья поиска	

## АТД двоичное дерево на массиве


# Билет 8
## Разнофиксные формы записи алгебраических выражений	

## Реализация АТД бинарного дерева на динамических структурах

# Билет 9
## Хэширование и рехеширование	

## Реализация АТД кольцевой список динамическая структура данных

# Билет 10
## АТД двоичные деревья	

## Реализация атд очередь на динамических структурах данных 




## Сбалансированные дереья


## Деревья поиска 


## Стек


## Дек


## Куча 




