
# Билет 1
## Алгоритм Кнутта-Морриса-Партта(поиск подстроки в строке с помощью таблицы индексов)
Лирическое отступление
```
Алгоритм Кнута-Морриса-Парта - алгоритм поиска подстроки в строке, придуман в 1977 году, 
основная идея алгоритма 
сдвигать слово не полностью(как в прямом поиске где при несовпадении символа слово сдвигается на 1), 
а по максимальному префиксу 
```
Алгоритм КМП - предназначен для поиска подстроки в строке, позволяет выпонлять поиск с линейной сложность O(n), где n - длина строки в которой производится поиск. Алгоритм использует таблицу Префиксов и Суффиксов которая позволяет понять с какой пощиции начать если сравнение неудачное( не равны символы).

Сам алгоритм выглядит так 

1. Создается таблица префиксов и суффиксов подстроки  
2. Инициализируются переменные для сравнения: `i` - индекс строки, `j` - индекс символа  
3. Начинается сравнение подстроки с строкой с текущих индексов `i` и `j`  
    - Если символы совпали, то увеличиваем `i` и `j` на 1  
    - Если символы не совпали:  
        - Пока `j > 0`:  
            - `i` оставляем неизменным, а вместо `j` ставим элемент из таблицы с индексом `[j - 1]`  
        - Если `j == 0`:  
            - Прибавляем 1 к `i`  
4. Повторяем шаг 3, пока не достигнут конец строки или образца  
5. Если достигнут конец подстроки, то найдено полное совпадение. Возвращаем позицию в строке, где начинается совпадение  
6. Если кончилась строка, то совпадение не найдено  


Благодаря таблице префиксов и суффиксов алгоритм позволяет избежать многократный сравнений уже проверенных символов. Это похволяет достичь более быстрого и эффективного поиска подстроки в строке.ъ

## ЗАДАЧА быстрая сортировка хоара рекурсивно
[полезное видео](https://youtu.be/HjVE1ei28_I?si=Y4qOvQkKbFxk9lYZ)
Сортировка Хоара, также известная как быстрая сортировка, является одним из самых популярных
алгоритмов сортировки. Он был разработан сэром Чарльзом Хоаром в 1959 году и изначально
представлялся в виде разделения массива на подмассивы, сортировки каждого из них отдельно и
объединения полученных результатов.
Алгоритм работает следующим образом:
1. Выбирается элемент массива, называемый опорным (pivot). Обычно в качестве опорного выбирается
средний элемент или случайный элемент.
2. Все элементы, меньшие опорного, перемещаются влево от него, а все элементы, большие опорного,
перемещаются вправо от него. После этого опорный элемент оказывается на своем окончательном
месте.
3. Процедура рекурсивно применяется к подмассивам слева и справа от опорного элемента.
Плюсы сортировки Хоара:
1. Быстрая: В большинстве случаев демонстрирует хорошую производительность. В среднем его
сложность O(n log n).
2. Использует простые операции: применяет только простые операции сравнения и обмена элементов
массива.
3. Использует пространство памяти в малых количествах: выполняет сортировку на месте, то есть не
требует дополнительной памяти для хранения отсортированного массива.
Минусы сортировки Хоара:
1. Неустойчивость: не гарантирует сохранение порядка равных элементов. Это может быть проблемой,
если необходимо сортировать объекты с несколькими ключами.
2. Худший случай: В худшем случае, когда выбирается неподходящий опорный элемент или массив уже
отсортирован в обратном порядке, время выполнения QuickSort может быть O(n^2), что делает его менее
эффективным по сравнению с другими алгоритмами, такими как сортировка слиянием.
3. Рекурсивные вызовы: QuickSort использует рекурсию для сортировки подмассивов, что может
вызывать проблемы с памятью при обработке очень больших массивов.
Сложностная оценка сортировки Хоара: O(n log n), в худшем случае: O(n^2)
```
#include <stdio.h>

// Быстрая сортировка Хоара (рекурсивно)
void quicksort(int *a, int l, int r) {
    if (l >= r) return;                // Базовый случай
    int x = a[(l + r) / 2], i = l, j = r; // Опорный элемент и два указателя
    while (i <= j) {
        while (a[i] < x) i++;          // Ищем слева
        while (a[j] > x) j--;          // Ищем справа
        if (i <= j) {                  // Обмен
            int t = a[i]; a[i] = a[j]; a[j] = t;
            i++; j--;
        }
    }
    quicksort(a, l, j);                // Сортируем левую часть
    quicksort(a, i, r);                // Сортируем правую часть
}

int main() {
    int arr[] = {34, 7, 23, 32, 5, 62};
    int n = sizeof(arr)/sizeof(arr[0]);
    quicksort(arr, 0, n-1);            // Сортировка
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);         // Вывод результата
    return 0;
}
```
# Билет 2
## алгоритм Бойера-Мура	
[Полезное видео](https://youtu.be/CKxBGZdN0t8?si=Zxp_4kLayRCP-zx8)
Алгоритм Байера-Мура - алгоритм для поиска подстроки в строке с помощью таблицы сдвигов, алгоритм проходится по слову справа-налево.

1. Составляется таблица сдвигов char(символ в подстроке) | shift(максимальный сдвиг вычасляющийся по формуле max(1, длина подстроки - 1 - позиуия символа в подстроке))
2. Вводятся индексы i - текущий символ в строке j - символ в подстроке
3. Начинается проверка символов справа налево 
   - Если символы совпали:
        - i - 1, j - 1 (идем сравнивать дальше)
   - Если символы не воспали:
        - Если символ есть в таблице сдвигов:
            - смотрим величину сдвига(shift) данного символа и сдвигаемся на эту величину меняя  по символу текста i 
        - Если символа нет в таблице сдвигов:
            - Сдвигаемся на всю длину шаблона 
4. Повторяем пункт 3 пока i < меньше длины текста 
5. если j = 0, то полное совпадение найдено 
6. если закончилась строка, а j > 0, то совпадений нет 

Основная эффуктивность алгоритма достигается за счет таблицы сдвигов, которая позволяет "пропускать" участки в которых нет совпадений.

##  ЗАДАЧА решение выражения ПОЛИЗ(Обратная польская) на С 
```
#include <stdio.h>      // Подключаем стандартную библиотеку для ввода-вывода (printf)
#include <stdlib.h>     // Подключаем стандартную библиотеку для работы с памятью (malloc, free)
#include <ctype.h>      // Для проверки символов (isdigit)

#define MAX 100         // Максимальный размер стека

// Функция вычисления значения выражения в обратной польской записи (ПОЛИЗ)
int evalRPN(char *expr) {
    int stack[MAX], top = -1;      // Объявляем стек и переменную для вершины стека
    for (int i = 0; expr[i]; i++) { // Проходим по каждому символу выражения
        if (isdigit(expr[i])) {      // Если текущий символ — цифра
            stack[++top] = expr[i] - '0'; // Преобразуем символ в число и кладём на стек
        } else if (expr[i] == ' ') { // Если пробел — пропускаем
            continue;
        } else {                     // Если оператор (+, -, *, /)
            int b = stack[top--];    // Снимаем второй операнд со стека
            int a = stack[top--];    // Снимаем первый операнд со стека
            switch (expr[i]) {       // Выполняем операцию
                case '+': stack[++top] = a + b; break; // Складываем
                case '-': stack[++top] = a - b; break; // Вычитаем
                case '*': stack[++top] = a * b; break; // Умножаем
                case '/': stack[++top] = a / b; break; // Делим
            }
        }
    }
    return stack[top];               // Возвращаем результат (на вершине стека)
}

int main() {
    char expr[] = "2 3 + 4 *";       // Пример выражения: (2 + 3) * 4 = 20
    printf("Result: %d\n", evalRPN(expr)); // Выводим результат вычисления
    return 0;                        // Завершаем программу
}
```

# Билет 3
## Алгоритм Рабина карпа	
 
## ЗАДАЧА Сортировка Шелла на Си реализация


# Билет 4
## атд двунаправленный кольцевой список 	

## ЗАДАЧА быстрая сортировка Хоара (не рекурсия)


# Билет 5
## сбалансированные деревья	

## ЗАДАЧА реализация атд очереди на массиве


# Билет 6
## атд двоичное дерево	реализация 

## ЗАДАЧА атд очередь динамических структур данных


# Билет 7
## Сбалансированные деревья поиска	

## ЗАДАЧА АТД двоичное дерево на массиве


# Билет 8
## Разнофиксные формы записи алгебраических выражений	

## ЗАДАЧА Реализация АТД бинарного дерева на динамических структурах

# Билет 9
## Хэширование и рехеширование	

## ЗАДАЧА Реализация АТД кольцевой список динамическая структура данных

# Билет 10
## АТД двоичные деревья	

## ЗАДАЧА Реализация атд очередь на динамических структурах данных 








