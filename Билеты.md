
# Билет 1
## Алгоритм Кнутта-Морриса-Партта(поиск подстроки в строке с помощью таблицы индексов)
Лирическое отступление
```
Алгоритм Кнута-Морриса-Парта - алгоритм поиска подстроки в строке, придуман в 1977 году, 
основная идея алгоритма 
сдвигать слово не полностью(как в прямом поиске где при несовпадении символа слово сдвигается на 1), 
а по максимальному префиксу 
```
Алгоритм КМП - предназначен для поиска подстроки в строке, позволяет выпонлять поиск с линейной сложность O(n), где n - длина строки в которой производится поиск. Алгоритм использует таблицу Префиксов и Суффиксов которая позволяет понять с какой пощиции начать если сравнение неудачное( не равны символы).

Сам алгоритм выглядит так 

1. Создается таблица префиксов и суффиксов подстроки  
2. Инициализируются переменные для сравнения: `i` - индекс строки, `j` - индекс символа  
3. Начинается сравнение подстроки с строкой с текущих индексов `i` и `j`  
    - Если символы совпали, то увеличиваем `i` и `j` на 1  
    - Если символы не совпали:  
        - Пока `j > 0`:  
            - `i` оставляем неизменным, а вместо `j` ставим элемент из таблицы с индексом `[j - 1]`  
        - Если `j == 0`:  
            - Прибавляем 1 к `i`  
4. Повторяем шаг 3, пока не достигнут конец строки или образца  
5. Если достигнут конец подстроки, то найдено полное совпадение. Возвращаем позицию в строке, где начинается совпадение  
6. Если кончилась строка, то совпадение не найдено  


Благодаря таблице префиксов и суффиксов алгоритм позволяет избежать многократный сравнений уже проверенных символов. Это похволяет достичь более быстрого и эффективного поиска подстроки в строке.ъ

## ЗАДАЧА быстрая сортировка хоара рекурсивно
[полезное видео](https://youtu.be/HjVE1ei28_I?si=Y4qOvQkKbFxk9lYZ)
Сортировка Хоара, также известная как быстрая сортировка, является одним из самых популярных
алгоритмов сортировки. Он был разработан сэром Чарльзом Хоаром в 1959 году и изначально
представлялся в виде разделения массива на подмассивы, сортировки каждого из них отдельно и
объединения полученных результатов.
Алгоритм работает следующим образом:
1. Выбирается элемент массива, называемый опорным (pivot). Обычно в качестве опорного выбирается
средний элемент или случайный элемент.
2. Все элементы, меньшие опорного, перемещаются влево от него, а все элементы, большие опорного,
перемещаются вправо от него. После этого опорный элемент оказывается на своем окончательном
месте.
3. Процедура рекурсивно применяется к подмассивам слева и справа от опорного элемента.
Плюсы сортировки Хоара:
1. Быстрая: В большинстве случаев демонстрирует хорошую производительность. В среднем его
сложность O(n log n).
2. Использует простые операции: применяет только простые операции сравнения и обмена элементов
массива.
3. Использует пространство памяти в малых количествах: выполняет сортировку на месте, то есть не
требует дополнительной памяти для хранения отсортированного массива.
Минусы сортировки Хоара:
1. Неустойчивость: не гарантирует сохранение порядка равных элементов. Это может быть проблемой,
если необходимо сортировать объекты с несколькими ключами.
2. Худший случай: В худшем случае, когда выбирается неподходящий опорный элемент или массив уже
отсортирован в обратном порядке, время выполнения QuickSort может быть O(n^2), что делает его менее
эффективным по сравнению с другими алгоритмами, такими как сортировка слиянием.
3. Рекурсивные вызовы: QuickSort использует рекурсию для сортировки подмассивов, что может
вызывать проблемы с памятью при обработке очень больших массивов.
Сложностная оценка сортировки Хоара: O(n log n), в худшем случае: O(n^2)
```
#include <stdio.h>

// Быстрая сортировка Хоара (рекурсивно)
void quicksort(int *a, int l, int r) {
    if (l >= r) return;                // Базовый случай
    int x = a[(l + r) / 2], i = l, j = r; // Опорный элемент и два указателя
    while (i <= j) {
        while (a[i] < x) i++;          // Ищем слева
        while (a[j] > x) j--;          // Ищем справа
        if (i <= j) {                  // Обмен
            int t = a[i]; a[i] = a[j]; a[j] = t;
            i++; j--;
        }
    }
    quicksort(a, l, j);                // Сортируем левую часть
    quicksort(a, i, r);                // Сортируем правую часть
}

int main() {
    int arr[] = {34, 7, 23, 32, 5, 62};
    int n = sizeof(arr)/sizeof(arr[0]);
    quicksort(arr, 0, n-1);            // Сортировка
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);         // Вывод результата
    return 0;
}
```
# Билет 2
## алгоритм Бойера-Мура	
[Полезное видео](https://youtu.be/CKxBGZdN0t8?si=Zxp_4kLayRCP-zx8)
Алгоритм Байера-Мура - алгоритм для поиска подстроки в строке с помощью таблицы сдвигов, алгоритм проходится по слову справа-налево.

1. Составляется таблица сдвигов char(символ в подстроке) | shift(максимальный сдвиг вычасляющийся по формуле max(1, длина подстроки - 1 - позиуия символа в подстроке))
2. Вводятся индексы i - текущий символ в строке j - символ в подстроке
3. Начинается проверка символов справа налево 
   - Если символы совпали:
        - i - 1, j - 1 (идем сравнивать дальше)
   - Если символы не воспали:
        - Если символ есть в таблице сдвигов:
            - смотрим величину сдвига(shift) данного символа и сдвигаемся на эту величину меняя  по символу текста i 
        - Если символа нет в таблице сдвигов:
            - Сдвигаемся на всю длину шаблона 
4. Повторяем пункт 3 пока i < меньше длины текста 
5. если j = 0, то полное совпадение найдено 
6. если закончилась строка, а j > 0, то совпадений нет 

Основная эффуктивность алгоритма достигается за счет таблицы сдвигов, которая позволяет "пропускать" участки в которых нет совпадений.

##  ЗАДАЧА решение выражения ПОЛИЗ(Обратная польская) на С 
```
#include <stdio.h>      // Подключаем стандартную библиотеку для ввода-вывода (printf)
#include <stdlib.h>     // Подключаем стандартную библиотеку для работы с памятью (malloc, free)
#include <ctype.h>      // Для проверки символов (isdigit)

#define MAX 100         // Максимальный размер стека

// Функция вычисления значения выражения в обратной польской записи (ПОЛИЗ)
int evalRPN(char *expr) {
    int stack[MAX], top = -1;      // Объявляем стек и переменную для вершины стека
    for (int i = 0; expr[i]; i++) { // Проходим по каждому символу выражения
        if (isdigit(expr[i])) {      // Если текущий символ — цифра
            stack[++top] = expr[i] - '0'; // Преобразуем символ в число и кладём на стек
        } else if (expr[i] == ' ') { // Если пробел — пропускаем
            continue;
        } else {                     // Если оператор (+, -, *, /)
            int b = stack[top--];    // Снимаем второй операнд со стека
            int a = stack[top--];    // Снимаем первый операнд со стека
            switch (expr[i]) {       // Выполняем операцию
                case '+': stack[++top] = a + b; break; // Складываем
                case '-': stack[++top] = a - b; break; // Вычитаем
                case '*': stack[++top] = a * b; break; // Умножаем
                case '/': stack[++top] = a / b; break; // Делим
            }
        }
    }
    return stack[top];               // Возвращаем результат (на вершине стека)
}

int main() {
    char expr[] = "2 3 + 4 *";       // Пример выражения: (2 + 3) * 4 = 20
    printf("Result: %d\n", evalRPN(expr)); // Выводим результат вычисления
    return 0;                        // Завершаем программу
}
```

# Билет 3
## Алгоритм Рабина карпа	
Алгоритм Рабина-Карпа, предназначен для поиска подстроки в строке путем хеширования по таблице горнера. Чтобы избегать переполнения берется число по модулю q (простое число, выбирается так чтобы вмещаться в машинное слово)

Алгоритм

1. Хешируется подстрока
2. СТрока хешируется отрезками длиной образца(подстроки)
3. Сравниваются хеши подстроки и отрезков строки, если найдено совпадение то начинаем посимвольную проверку

В обычном случае сложность алгоритма O(n + m), где n - длина строки, m - длина подстроки, но в сложных случая может занимать O(m * (n - m + 1)) времени. Кроме того, использование модуля q и выбор подходящего простого числа позволяет снизить вероятность ложных срабатываний при поиске.

## ЗАДАЧА Сортировка Шелла на Си реализация
```
#include <stdio.h> // Подключаем стандартную библиотеку для вывода на экран

// Сортировка Шелла
void shellSort(int arr[], int n) { // arr[] — массив для сортировки, n — его размер
    for (int gap = n/2; gap > 0; gap /= 2) {      // gap — шаг сравнения, уменьшается вдвое на каждом этапе
        for (int i = gap; i < n; i++) {           // i — индекс текущего элемента, начинаем с gap до конца массива
            int temp = arr[i], j = i;             // temp — сохраняем текущий элемент, j — индекс для перемещения
            while (j >= gap && arr[j-gap] > temp) { // Пока j не меньше gap и элемент слева больше temp
                arr[j] = arr[j-gap];              // Сдвигаем больший элемент вправо
                j -= gap;                         // Переходим к следующей позиции на расстоянии gap
            }
            arr[j] = temp;                        // Вставляем temp на найденное место
        }
    }
}
int main() {
    int arr[] = {23, 12, 1, 8, 34, 54, 2, 3};     // Исходный массив для сортировки
    int n = sizeof(arr)/sizeof(arr[0]);           // Вычисляем количество элементов в массиве
    shellSort(arr, n);                            // Вызываем сортировку Шелла для массива arr длины n
    for (int i = 0; i < n; i++)                   // Проходим по всем элементам массива
        printf("%d ", arr[i]);                    // Выводим отсортированный элемент на экран
    return 0;                                     // Завершаем программу
}
```

# Билет 4
## атд двунаправленный кольцевой список 	
[ЗАВТРА ПОСМОТРЕТЬ](https://youtu.be/lQ-lPjbb9Ew?si=KZOjUKk_xxVPNzws)
Двунаправленный кольцевой список — это структура данных, состоящая из узлов, каждый из которых содержит данные и два указателя: на следующий узел (next) и на предыдущий узел (prev). Особенность этой структуры заключается в том, что последний узел соединён с первым, а первый узел с последним, образуя кольцо. Благодаря этому движение по списку возможно в обе стороны, и любой узел может служить началом обхода.

**Отличие от других списков.** В отличие от односвязного списка, где движение возможно только вперёд и последний узел указывает на NULL, и двусвязного линейного списка, где есть указатели на предыдущий и следующий узел, но конец списка всё равно фиксирован, двунаправленный кольцевой список является циклическим, что позволяет начинать обход с любого узла и перемещаться бесконечно по кругу при необходимости.

**Основные операции.** Создание списка начинается с одного узла, у которого указатели next и prev указывают на самого себя. Вставка узла может выполняться в начало, конец или середину списка, при этом всегда корректируются указатели соседних узлов, чтобы сохранить кольцевую структуру. Удаление узла также требует обновления указателей соседей, а если удаляется единственный узел, список становится пустым. Обход списка может осуществляться как по next, так и по prev, что позволяет двигаться вперёд или назад. Поиск элемента производится последовательным перебором узлов до нахождения совпадения.

**Преимущества.** Двунаправленный кольцевой список позволяет перемещаться в обе стороны, можно начинать обход с любого узла, а кольцевая структура делает его удобным для реализации деков, двусторонних очередей и циклических буферов.

**Недостатки.** Эта структура требует дополнительной памяти для указателей, сложнее реализуется по сравнению с линейными списками и при некорректном обновлении указателей возможно нарушение кольцевой структуры.

**Пример реализации в C.** Для создания узла используют структуру с полями data, next и prev, при инициализации одного узла его указатели на следующий и предыдущий узел указывают на самого себя. При добавлении или удалении новых узлов необходимо корректировать соседние указатели, чтобы сохранить кольцевую связь между элементами.

**Использование.** Двунаправленные кольцевые списки применяются для реализации деков и двусторонних очередей, циклических буферов задач, игровых циклов, таких как карусели и карты, а также в алгоритмах типа Джозефа или круговых очередей.

В итоге, двунаправленный кольцевой список объединяет преимущества двусвязного списка и кольцевой структуры, позволяя эффективно реализовывать двусторонний обход и циклические операции.


## ЗАДАЧА быстрая сортировка Хоара (не рекурсия)
```
#include <stdio.h> // Подключаем стандартную библиотеку для вывода на экран

// Быстрая сортировка Хоара без рекурсии
void quicksort(int *a, int n) { // a — массив, n — его размер
    int stack[100], top = -1;   // stack — вспомогательный стек для границ, top — вершина стека
    int l = 0, r = n - 1;       // l — левая граница, r — правая граница массива
    stack[++top] = l; stack[++top] = r; // Кладём начальные границы в стек

    while (top >= 0) {          // Пока стек не пуст
        r = stack[top--];       // Снимаем правую границу
        l = stack[top--];       // Снимаем левую границу
        if (l >= r) continue;   // Если подмассив пуст или из одного элемента — пропускаем
        int x = a[(l + r) / 2], i = l, j = r; // x — опорный элемент, i/j — указатели
        while (i <= j) {        // Пока указатели не пересеклись
            while (a[i] < x) i++; // Двигаем i вправо, пока элемент меньше опорного
            while (a[j] > x) j--; // Двигаем j влево, пока элемент больше опорного
            if (i <= j) {          // Если указатели не пересеклись — меняем элементы местами
                int t = a[i]; a[i] = a[j]; a[j] = t;
                i++; j--;
            }
        }
        stack[++top] = l; stack[++top] = j; // Кладём в стек границы левой части
        stack[++top] = i; stack[++top] = r; // Кладём в стек границы правой части
    }
}

int main() {
    int arr[] = {34, 7, 23, 32, 5, 62}; // Исходный массив для сортировки
    int n = sizeof(arr)/sizeof(arr[0]); // Вычисляем количество элементов в массиве
    quicksort(arr, n);                  // Вызываем сортировку
    for (int i = 0; i < n; i++)         // Проходим по всем элементам массива
        printf("%d ", arr[i]);          // Выводим отсортированный элемент на экран
    return 0;                           // Завершаем программу
}
```

# Билет 5
## сбалансированные деревья	

## ЗАДАЧА реализация атд очереди на массиве


# Билет 6
## атд двоичное дерево	реализация 

## ЗАДАЧА атд очередь динамических структур данных


# Билет 7
## Сбалансированные деревья поиска	

## ЗАДАЧА АТД двоичное дерево на массиве


# Билет 8
## Разнофиксные формы записи алгебраических выражений	

## ЗАДАЧА Реализация АТД бинарного дерева на динамических структурах

# Билет 9
## Хэширование и рехеширование	

## ЗАДАЧА Реализация АТД кольцевой список динамическая структура данных

# Билет 10
## АТД двоичные деревья	

## ЗАДАЧА Реализация атд очередь на динамических структурах данных 








